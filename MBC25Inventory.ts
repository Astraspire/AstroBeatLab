import * as hz from "horizon/core";
import { Component, Player } from "horizon/core";
import { Inventory } from "./SoundPackTypes";
import { changeActiveMBC, checkMBCInventory, dropMBC, unlockMBC25, requestMBCActivation, inventoryUpdated } from "./shared-events-MBC25";
import { PACK_ID_BITS, addDefaultPacks, maskToPackList } from "./PackIdBitmask";

/**
 * Persistent variable key storing each player's unlocked pack bitmask.
 * Horizon Worlds keeps these values across sessions, allowing us to rebuild the
 * runtime inventory UI the next time the player joins.
 */
const SOUND_PACKS_PPV = "MBC25Inventory:unlockedSoundPacks";

export default class MBC25Inventory extends Component<typeof MBC25Inventory> {
    static propsDefinition = {
    }

    /** Current performer controlling an MBC25, recorded by player name. */
    private activePerformer!: string;

    /**
     * Returns the player's unlocked packs as {@link Inventory} records.
     * Ensures default packs are present by rewriting the stored bitmask when needed.
     */
    private getUnlockedPacks(player: Player): Inventory[] {
        const raw = this.world.persistentStorage.getPlayerVariable<number>(
            player,
            SOUND_PACKS_PPV
        );
        let mask = raw ?? 0;
        const updated = addDefaultPacks(mask);
        if (updated !== mask) {
            mask = updated;
            this.world.persistentStorage.setPlayerVariable(
                player,
                SOUND_PACKS_PPV,
                mask
            );
        }
        return maskToPackList(mask);
    }

    /**
     * Resolves the Player object matching the provided display name.
     * Many Horizon events surface player names as strings; this helper maps them back.
     */
    private findPlayerByName(playerName: string): Player | null {
        return (
            this.world
                .getPlayers()
                .find(p => p.name.get() === playerName)
            ?? null
        );
    }

    /**
     * Convenience logger that confirms the given inventory entry exists.
     * Placeholder for future expansion into richer pack metadata.
     */
    private getFullInventory(playerInventory: Inventory) {
        console.log(`${playerInventory.packId} is unlocked in inventory.`);
    }

    /**
     * Logs the player's current inventory for debugging and QA validation.
     */
    private printUserInventory(player: Player): void {
        if (player) {
            const inventory = this.getUnlockedPacks(player);
            for (const item of inventory) {
                console.log(`NEW: ${JSON.stringify(item)} is owned by ${player.name.get()}!!!`);
            }
            console.log(`OLD: ${JSON.stringify(inventory)} is owned by ${player.name.get()}.`);
        } else {
            console.log(`Invalid user for inventory check.`);
        }
    }

    /**
     * Unlocks the specified pack for the player and notifies dependent systems.
     * Updates the stored bitmask, emits inventory update events, and triggers drop checks.
     */
    private unlockSoundPack(playerName: string, packId: string): void {
        const player = this.findPlayerByName(playerName);
        if (!player) return;
        const bit = PACK_ID_BITS[packId];
        if (bit === undefined) return;
        let mask = this.world.persistentStorage.getPlayerVariable<number>(
            player,
            SOUND_PACKS_PPV
        ) ?? 0;
        if ((mask & bit) === 0) {
            mask |= bit;
            this.world.persistentStorage.setPlayerVariable(
                player,
                SOUND_PACKS_PPV,
                mask
            );
            console.log(`${playerName} now unlocked the ${packId} pack!`);
            // Let UI layers know they should refresh their inventory view.
            this.sendLocalBroadcastEvent(inventoryUpdated, { playerName });
        } else {
            console.log(`${playerName} already owns the ${packId} pack.`);
        }

    }

    /** Clears the active performer slot when the performer exits the world. */
    private resetActivePerformer(player: hz.Player): void {

        if (player.name.get() === this.activePerformer) {
            this.activePerformer = "";
        }

    }

    preStart() {
        // Handle activation and swap requests generated by UI panels.
        this.connectLocalEvent(
            this.entity!,
            requestMBCActivation,
            (requestData) => {
                console.log(`${requestData.playerName} is attempting to activated MBC25 id: ${requestData.packId}.`);
                if (requestData.playerName === this.activePerformer) {
                    // Keep the same performer but swap to the requested pack.
                    this.sendLocalBroadcastEvent(
                        dropMBC,
                        { packId: requestData.packId }
                    )
                } else if (this.activePerformer === "") {
                    // First performer claims the stage and spawns their pack.
                    this.sendLocalBroadcastEvent(
                        dropMBC,
                        { packId: requestData.packId }
                    )
                    // Remember who is currently performing.
                    this.activePerformer = requestData.playerName;
                    console.log(`${this.activePerformer} is now the active performer.`)
                } else {
                    console.log(`${requestData.playerName} request to change MBC25 is denied, ${this.activePerformer} is still performing!`)
                }
            }
        )

        // Print the requester's inventory contents when a trigger asks for it.
        this.connectLocalEvent(
            this.entity!,
            checkMBCInventory,
            ({ playerId }) => {
                console.log(`checkMBCInventory event is received.`);
                this.printUserInventory(playerId);
            }
        );

        // Persist new pack unlocks and propagate them throughout the world.
        this.connectLocalEvent(
            this.entity!,
            unlockMBC25,
            (unlockData) => {
                console.log(`${unlockData.playerName} triggered an unlock for the '${unlockData.packId}' pack!`);
                this.unlockSoundPack(unlockData.playerName, unlockData.packId);
            }
        );


        this.connectCodeBlockEvent(
            this.entity!,
            hz.CodeBlockEvents.OnPlayerExitWorld,
            this.resetActivePerformer
        );

    }

    start() {
        // Nothing extra to initialize at start.
    }
}

Component.register(MBC25Inventory);
